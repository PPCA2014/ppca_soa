{"version":3,"file":"swap-component.directive.js","sourceRoot":"","sources":["../../../src/angular2-modal/components/swap-component.directive.ts"],"names":[],"mappings":"OAAO,EAEL,SAAS,EACT,KAAK,EACL,MAAM,EACN,kBAAkB,EAElB,gBAAgB,EAChB,wBAAwB,EACxB,YAAY,EACZ,WAAW,EAEZ,MAAM,eAAe;AAEtB,uEAAuE;AACvE,6HAA6H;AAG7H;IAGE,gCAAoB,GAA6B,EAC7B,KAAuB,EACvB,IAAyB;QAFzB,QAAG,GAAH,GAAG,CAA0B;QAC7B,UAAK,GAAL,KAAK,CAAkB;QACvB,SAAI,GAAJ,IAAI,CAAqB;QAO5C,aAAQ,GAAoC,IAAI,YAAY,CAAoB,KAAK,CAAC,CAAC;IANxF,CAAC;IAQA,sBAAI,2CAAO;aAAX,UAAY,SAAc;YACzB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;YACnB,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;gBACnB,IAAI,QAAQ,GAAG,IAAI,CAAC,eAAe,IAAI,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC;gBAEjE,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC3E,QAAQ,GAAG,kBAAkB,CAAC,qBAAqB,CAAC,IAAI,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;gBACtF,CAAC;gBAED,IAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CACvC,IAAI,CAAC,GAAG,CAAC,uBAAuB,CAAC,SAAS,CAAC,EAC3C,IAAI,CAAC,KAAK,CAAC,MAAM,EACjB,QAAQ,EACR,IAAI,CAAC,mBAAmB,CACzB,CAAC;gBAEF,MAAM,CAAC,iBAAiB,CAAC,aAAa,EAAE,CAAC;gBAEzC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC7B,CAAC;QACH,CAAC;;;OAAA;IACI,iCAAU,GAA0B;QAC3C,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;oBACxB,QAAQ,EAAE,WAAW;iBACtB,EAAG,EAAE;KACL,CAAC;IACF,kBAAkB;IACX,qCAAc,GAA6D;QAClF,EAAC,IAAI,EAAE,wBAAwB,GAAG;QAClC,EAAC,IAAI,EAAE,gBAAgB,GAAG;QAC1B,EAAC,IAAI,EAAE,WAAW,GAAG;KACpB,CAAC;IACK,qCAAc,GAA2C;QAChE,iBAAiB,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;QACrC,iBAAiB,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;QACrC,qBAAqB,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;QACzC,UAAU,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE;QAC/B,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE;KAC5B,CAAC;IACF,6BAAC;AAAD,CAAC,AAtDD,IAsDC","sourcesContent":["import {\n  ComponentRef,\n  Directive,\n  Input,\n  Output,\n  ReflectiveInjector,\n  ResolvedReflectiveProvider,\n  ViewContainerRef,\n  ComponentFactoryResolver,\n  EventEmitter,\n  TemplateRef,\n  Injector\n} from '@angular/core';\n\n// <template [dynCmp]=\"myCmp\" [dynCmpBindings]=\"myBindings\"></template>\n// <template [dynCmp]=\"ctx.component\" [dynCmpBindings]=\"ctx.bindings\" [dynCmpProjectables]=\"ctx.projectableNodes\"></template>\n\n\nexport class SwapComponentDirective {\n  private component: any;\n\n  constructor(private cfr: ComponentFactoryResolver,\n              private vcRef: ViewContainerRef,\n              private tRef: TemplateRef<Object>) {\n  }\n\n   swapCmpBindings: ResolvedReflectiveProvider[];\n   swapCmpInjector: Injector;\n   swapCmpProjectables: any[][];\n\n   onCreate: EventEmitter<ComponentRef<any>> = new EventEmitter<ComponentRef<any>>(false);\n\n   set swapCmp(component: any) {\n    this.component = component;\n    this.vcRef.clear();\n    if (this.component) {\n      let injector = this.swapCmpInjector || this.vcRef.parentInjector;\n\n      if (Array.isArray(this.swapCmpBindings) && this.swapCmpBindings.length > 0) {\n        injector = ReflectiveInjector.fromResolvedProviders(this.swapCmpBindings, injector);\n      }\n\n      const cmpRef = this.vcRef.createComponent(\n        this.cfr.resolveComponentFactory(component),\n        this.vcRef.length,\n        injector,\n        this.swapCmpProjectables\n      );\n\n      cmpRef.changeDetectorRef.detectChanges();\n\n      this.onCreate.emit(cmpRef);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[swapCmp]'\n}, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: ({type: any, decorators?: DecoratorInvocation[]}|null)[] = [\n{type: ComponentFactoryResolver, },\n{type: ViewContainerRef, },\n{type: TemplateRef, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'swapCmpBindings': [{ type: Input },],\n'swapCmpInjector': [{ type: Input },],\n'swapCmpProjectables': [{ type: Input },],\n'onCreate': [{ type: Output },],\n'swapCmp': [{ type: Input },],\n};\n}\n\n// <component-linker [linkedComponent]=\"ctx.component\" [bindings]=\"ctx.bindings\"></component-linker>\n// @Component({\n//   selector: 'component-linker',\n//   template: ''\n// })\n// export class ComponentLinker {\n//\n//   @Input() linkedComponent: any;\n//   @Input() bindings: ResolvedReflectiveProvider[];\n//\n//   @Output() onCreate: EventEmitter<ComponentRef<any>> = new EventEmitter<ComponentRef<any>>(false);\n//   constructor(private vcRef: ViewContainerRef, private cfr: ComponentFactoryResolver) {\n//\n//   }\n//\n//   ngAfterViewInit() {\n//     let injector = this.vcRef.parentInjector;\n//\n//     if (Array.isArray(this.bindings) && this.bindings.length > 0) {\n//       injector = ReflectiveInjector.fromResolvedProviders(this.bindings, injector);\n//     }\n//\n//     const cmpRef = this.vcRef.createComponent(\n//       this.cfr.resolveComponentFactory(this.linkedComponent),\n//       this.vcRef.length,\n//       injector\n//     );\n//\n//     cmpRef.changeDetectorRef.detectChanges();\n//\n//     this.onCreate.emit(cmpRef);\n//   }\n// }\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}